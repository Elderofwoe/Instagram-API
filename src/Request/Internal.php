<?php

namespace InstagramAPI\Request;

use InstagramAPI\Client;
use InstagramAPI\Constants;
use InstagramAPI\Request;
use InstagramAPI\Response;
use InstagramAPI\Signatures;
use InstagramAPI\Utils;
use function GuzzleHttp\Psr7\stream_for;

/**
 * Collection of various INTERNAL library functions.
 *
 * THESE FUNCTIONS ARE NOT FOR PUBLIC USE! DO NOT TOUCH!
 */
class Internal extends RequestCollection
{
    /**
     * UPLOADS A *SINGLE* PHOTO.
     *
     * @param string $targetFeed       Target feed for this media ("timeline", "story", "direct_story"
     *                                 but NOT "album", they are handled elsewhere).
     * @param string $photoFilename    The photo filename.
     * @param array  $internalMetadata (optional) Internal library-generated metadata key-value pairs.
     * @param array  $externalMetadata (optional) User-provided metadata key-value pairs.
     *
     * @throws \InvalidArgumentException
     * @throws \InstagramAPI\Exception\InstagramException
     *
     * @return \InstagramAPI\Response\ConfigureResponse
     *
     * @see Internal::configureSinglePhoto() for available metadata fields.
     */
    public function uploadSinglePhoto(
        $targetFeed,
        $photoFilename,
        array $internalMetadata = [],
        array $externalMetadata = [])
    {
        // Make sure we only allow these particular feeds for this function.
        if ($targetFeed != 'timeline' && $targetFeed != 'story' && $targetFeed != 'direct_story') {
            throw new \InvalidArgumentException(sprintf('Bad target feed "%s".', $targetFeed));
        }

        // Verify that the file exists locally.
        if (!is_file($photoFilename)) {
            throw new \InvalidArgumentException(sprintf('The photo file "%s" does not exist on disk.', $photoFilename));
        }

        // Determine the width and height of the photo.
        $imagesize = @getimagesize($photoFilename);
        if ($imagesize === false) {
            throw new \InvalidArgumentException(sprintf('File "%s" is not an image.', $photoFilename));
        }
        list($photoWidth, $photoHeight) = $imagesize;

        // Validate image resolution and aspect ratio.
        Utils::throwIfIllegalMediaResolution($targetFeed, 'photofile', $photoFilename, $photoWidth, $photoHeight);

        // Perform the upload.
        $upload = $this->uploadPhotoData($targetFeed, $photoFilename);

        // Configure the uploaded image and attach it to our timeline/story.
        $internalMetadata = array_merge($internalMetadata, [
            'uploadId'      => $upload->getUploadId(),
            'photoWidth'    => $photoWidth,
            'photoHeight'   => $photoHeight,
        ]);
        $configure = $this->configureSinglePhoto($targetFeed, $internalMetadata, $externalMetadata);

        return $configure;
    }

    /**
     * Upload the data for a photo to Instagram.
     *
     * @param string $targetFeed    Target feed for this media ("timeline", "story", "direct_story" or "album").
     * @param string $photoFilename The photo filename.
     * @param string $fileType      Whether the file is a "photofile" or "videofile".
     *                              In case of videofile we'll generate a thumbnail from it.
     * @param null   $uploadId      Custom upload ID if wanted. Otherwise autogenerated.
     *
     * @throws \InvalidArgumentException
     * @throws \InstagramAPI\Exception\InstagramException
     *
     * @return \InstagramAPI\Response\UploadPhotoResponse
     */
    public function uploadPhotoData(
        $targetFeed,
        $photoFilename,
        $fileType = 'photofile',
        $uploadId = null)
    {
        // Verify that the file exists locally.
        if (!is_file($photoFilename)) {
            throw new \InvalidArgumentException(sprintf('The photo file "%s" does not exist on disk.', $photoFilename));
        }

        // Determine which file contents to upload.
        if ($fileType == 'videofile') {
            // Generate a thumbnail from a video file.
            $photoData = Utils::createVideoIcon($photoFilename);
        } else {
            $photoData = file_get_contents($photoFilename);
        }

        // Generate an upload ID if none was provided.
        if (is_null($uploadId)) {
            $uploadId = Utils::generateUploadId();
        }

        // Prepare payload for the upload request.
        $request = $this->ig->request('upload/photo/')
            ->setSignedPost(false)
            ->addPost('upload_id', $uploadId)
            ->addPost('_uuid', $this->ig->uuid)
            ->addPost('_csrftoken', $this->ig->client->getToken())
            ->addPost('image_compression', '{"lib_name":"jt","lib_version":"1.3.0","quality":"87"}')
            ->addFileData('photo', $photoData, 'pending_media_'.Utils::generateUploadId().'.jpg');

        if ($targetFeed == 'album') {
            $request->addPost('is_sidecar', '1');
            if ($fileType == 'videofile') {
                $request->addPost('media_type', '2');
            }
        }

        return $request->getResponse(new Response\UploadPhotoResponse());
    }

    /**
     * Configures parameters for a *SINGLE* uploaded photo file.
     *
     * WARNING TO CONTRIBUTORS: THIS IS ONLY FOR *TIMELINE* AND *STORY* -PHOTOS-.
     * USE "configureTimelineAlbum()" FOR ALBUMS and "configureSingleVideo()" FOR VIDEOS.
     * AND IF FUTURE INSTAGRAM FEATURES NEED CONFIGURATION AND ARE NON-TRIVIAL,
     * GIVE THEM THEIR OWN FUNCTION LIKE WE DID WITH "configureTimelineAlbum()",
     * TO AVOID ADDING BUGGY AND UNMAINTAINABLE SPIDERWEB CODE!
     *
     * @param string $targetFeed       Target feed for this media ("timeline", "story", "direct_story"
     *                                 but NOT "album", they are handled elsewhere).
     * @param array  $internalMetadata Internal library-generated metadata key-value pairs.
     * @param array  $externalMetadata (optional) User-provided metadata key-value pairs.
     *
     * @throws \InvalidArgumentException
     * @throws \InstagramAPI\Exception\InstagramException
     *
     * @return \InstagramAPI\Response\ConfigureResponse
     */
    public function configureSinglePhoto(
        $targetFeed,
        array $internalMetadata,
        array $externalMetadata = [])
    {
        // Determine the target endpoint for the photo.
        switch ($targetFeed) {
        case 'timeline':
            $endpoint = 'media/configure/';
            break;
        case 'direct_story':
        case 'story':
            $endpoint = 'media/configure_to_story/';
            break;
        default:
            throw new \InvalidArgumentException(sprintf('Bad target feed "%s".', $targetFeed));
        }

        // Available external metadata parameters:
        /** @var string|null Caption to use for the media. NOT USED FOR STORY MEDIA! */
        $captionText = isset($externalMetadata['caption']) ? $externalMetadata['caption'] : null;
        /** @var Response\Model\Location|null A Location object describing where
         the media was taken. NOT USED FOR STORY MEDIA! */
        $location = (isset($externalMetadata['location']) && $targetFeed != 'story') ? $externalMetadata['location'] : null;
        /** @var array|null Array of usertagging instructions, in the format
         [['position'=>[0.5,0.5], 'user_id'=>'123'], ...]. ONLY FOR TIMELINE PHOTOS! */
        $usertags = (isset($externalMetadata['usertags']) && $targetFeed == 'timeline') ? $externalMetadata['usertags'] : null;
        /** @var void Photo filter. THIS DOES NOTHING! All real filters are done in the mobile app. */
        // $filter = isset($externalMetadata['filter']) ? $externalMetadata['filter'] : null;
        $filter = null; // COMMENTED OUT SO USERS UNDERSTAND THEY CAN'T USE THIS!

        // Fix very bad external user-metadata values.
        if (!is_string($captionText)) {
            $captionText = '';
        }

        // Critically important internal library-generated metadata parameters:
        /** @var string The ID of the entry to configure. */
        $uploadId = $internalMetadata['uploadId'];
        /** @var int|float Width of the photo. */
        $photoWidth = $internalMetadata['photoWidth'];
        /** @var int|float Height of the photo. */
        $photoHeight = $internalMetadata['photoHeight'];

        // Build the request...
        $request = $this->ig->request($endpoint)
            ->addPost('_csrftoken', $this->ig->client->getToken())
            ->addPost('_uid', $this->ig->account_id)
            ->addPost('_uuid', $this->ig->uuid)
            ->addPost('edits',
                [
                    'crop_original_size'    => [$photoWidth, $photoHeight],
                    'crop_zoom'             => 1,
                    'crop_center'           => [0.0, -0.0],
                ])
            ->addPost('device',
                [
                    'manufacturer'      => $this->ig->device->getManufacturer(),
                    'model'             => $this->ig->device->getModel(),
                    'android_version'   => $this->ig->device->getAndroidVersion(),
                    'android_release'   => $this->ig->device->getAndroidRelease(),
                ])
            ->addPost('extra',
                [
                    'source_width'  => $photoWidth,
                    'source_height' => $photoHeight,
                ]);

        switch ($targetFeed) {
            case 'timeline':
                $request
                    ->addPost('caption', $captionText)
                    ->addPost('source_type', '4')
                    ->addPost('media_folder', 'Camera')
                    ->addPost('upload_id', $uploadId);

                if ($usertags !== null) {
                    $usertags = ['in' => $usertags]; // Wrap in container array.
                    Utils::throwIfInvalidUsertags($usertags);
                    $request->addPost('usertags', json_encode($usertags));
                }
                break;
            case 'story':
                $request
                    ->addPost('client_shared_at', (string) time())
                    ->addPost('source_type', '3')
                    ->addPost('configure_mode', '1')
                    ->addPost('client_timestamp', (string) (time() - mt_rand(3, 10)))
                    ->addPost('upload_id', $uploadId);
                break;
            case 'direct_story':
                $request
                    ->addPost('recipient_users', $internalMetadata['recipient_users'])
                    ->addPost('thread_ids', $internalMetadata['thread_ids'])
                    ->addPost('client_shared_at', (string) time())
                    ->addPost('source_type', '3')
                    ->addPost('configure_mode', '2')
                    ->addPost('client_timestamp', (string) (time() - mt_rand(3, 10)))
                    ->addPost('upload_id', $uploadId);
                break;
        }

        if ($location instanceof Response\Model\Location) {
            $loc = [
                $location->getExternalIdSource().'_id'   => $location->getExternalId(),
                'name'                                   => $location->getName(),
                'lat'                                    => $location->getLat(),
                'lng'                                    => $location->getLng(),
                'address'                                => $location->getAddress(),
                'external_source'                        => $location->getExternalIdSource(),
            ];

            $request
                ->addPost('location', json_encode($loc))
                ->addPost('geotag_enabled', '1')
                ->addPost('posting_latitude', $location->getLat())
                ->addPost('posting_longitude', $location->getLng())
                ->addPost('media_latitude', $location->getLat())
                ->addPost('media_longitude', $location->getLng())
                ->addPost('av_latitude', 0.0)
                ->addPost('av_longitude', 0.0);
        }

        $configure = $request->getResponse(new Response\ConfigureResponse());

        return $configure;
    }

    /**
     * UPLOADS A *SINGLE* VIDEO.
     *
     * @param string $targetFeed       Target feed for this media ("timeline", "story", "direct_story",
     *                                 but NOT "album", they are handled elsewhere).
     * @param string $videoFilename    The video filename.
     * @param array  $internalMetadata (optional) Internal library-generated metadata key-value pairs.
     * @param array  $externalMetadata (optional) User-provided metadata key-value pairs.
     * @param int    $maxAttempts      (optional) Total attempts to upload all chunks before throwing.
     *
     * @throws \InvalidArgumentException
     * @throws \InstagramAPI\Exception\InstagramException
     * @throws \InstagramAPI\Exception\UploadFailedException If the video upload fails.
     *
     * @return \InstagramAPI\Response\ConfigureResponse
     *
     * @see Internal::configureSingleVideo() for available metadata fields.
     */
    public function uploadSingleVideo(
        $targetFeed,
        $videoFilename,
        array $internalMetadata = [],
        array $externalMetadata = [],
        $maxAttempts = 10)
    {
        // Make sure we only allow these particular feeds for this function.
        if ($targetFeed != 'timeline' && $targetFeed != 'story' && $targetFeed != 'direct_story') {
            throw new \InvalidArgumentException(sprintf('Bad target feed "%s".', $targetFeed));
        }

        // We require at least 1 attempt, otherwise we can't do anything.
        if ($maxAttempts < 1) {
            throw new \InvalidArgumentException('The maxAttempts parameter must be 1 or higher.');
        }

        // Verify that the file exists locally.
        if (!is_file($videoFilename)) {
            throw new \InvalidArgumentException(sprintf('The video file "%s" does not exist on disk.', $videoFilename));
        }

        // Figure out the video file details.
        // NOTE: We do this first, since it validates whether the video file is
        // valid and lets us avoid wasting time uploading totally invalid files!
        $internalMetadata['videoDetails'] = Utils::getVideoFileDetails($videoFilename);

        // Validate the video details and throw if Instagram won't allow it.
        Utils::throwIfIllegalVideoDetails($targetFeed, $videoFilename, $internalMetadata['videoDetails']);

        // Request parameters for uploading a new video.
        $uploadParams = $this->requestVideoUploadURL($targetFeed, $internalMetadata);
        $internalMetadata['uploadId'] = $uploadParams['uploadId'];

        // Attempt to upload the video data.
        $upload = $this->ig->internal->uploadVideoChunks($targetFeed, $videoFilename, $uploadParams, $maxAttempts);

        // Attempt to upload the thumbnail, associated with our video's ID.
        $this->uploadPhotoData($targetFeed, $videoFilename, 'videofile', $uploadParams['uploadId']);

        // Configure the uploaded video and attach it to our timeline/story.
        $configure = $this->configureSingleVideoWithRetries($targetFeed, $internalMetadata, $externalMetadata);

        return $configure;
    }

    /**
     * Asks Instagram for parameters for uploading a new video.
     *
     * @param string $targetFeed       Target feed for this media ("timeline", "story", "album" or "direct_v2").
     * @param array  $internalMetadata (optional) Internal library-generated metadata key-value pairs.
     *
     * @throws \InstagramAPI\Exception\InstagramException If the request fails.
     *
     * @return array
     */
    public function requestVideoUploadURL(
        $targetFeed,
        array $internalMetadata = [])
    {
        $uploadId = Utils::generateUploadId();

        $request = $this->ig->request('upload/video/')
            ->setSignedPost(false)
            ->addPost('upload_id', $uploadId)
            ->addPost('_csrftoken', $this->ig->client->getToken())
            ->addPost('_uuid', $this->ig->uuid);

        // Critically important internal library-generated metadata parameters:
        if ($targetFeed == 'album') {
            // NOTE: NO INTERNAL DATA IS NEEDED HERE YET.
            $request->addPost('is_sidecar', 1);
        } else {
            // Get all of the INTERNAL metadata needed for non-album videos.
            /** @var array Video details array. */
            $videoDetails = $internalMetadata['videoDetails'];
            $request
                ->addPost('media_type', '2')
                // NOTE: ceil() is to round up and get rid of any MS decimals.
                ->addPost('upload_media_duration_ms', (int) ceil($videoDetails['duration'] * 1000))
                ->addPost('upload_media_width', $videoDetails['width'])
                ->addPost('upload_media_height', $videoDetails['height']);

            if ($targetFeed === 'direct_v2') {
                $cropX = mt_rand(0, 128);
                $cropY = mt_rand(0, 128);
                $request
                    ->addPost('upload_media_width', '0')
                    ->addPost('upload_media_height', '0')
                    ->addPost('direct_v2', '1')
                    ->addPost('hflip', 'false')
                    ->addPost('rotate', '0')
                    ->addPost('crop_rect', json_encode([
                        $cropX,
                        $cropY,
                        $cropX + $videoDetails['width'],
                        $cropY + $videoDetails['height'],
                    ]));
            }
        }

        // Perform the "pre-upload" API request.
        /** @var Response\UploadJobVideoResponse $response */
        $response = $request->getResponse(new Response\UploadJobVideoResponse());

        // Determine where their API wants us to upload the video file.
        return [
            'uploadId'  => $uploadId,
            'uploadUrl' => $response->getVideoUploadUrls()[3]->url,
            'job'       => $response->getVideoUploadUrls()[3]->job,
        ];
    }

    /**
     * Configures parameters for a *SINGLE* uploaded video file.
     *
     * WARNING TO CONTRIBUTORS: THIS IS ONLY FOR *TIMELINE* AND *STORY* -VIDEOS-.
     * USE "configureTimelineAlbum()" FOR ALBUMS and "configureSinglePhoto()" FOR PHOTOS.
     * AND IF FUTURE INSTAGRAM FEATURES NEED CONFIGURATION AND ARE NON-TRIVIAL,
     * GIVE THEM THEIR OWN FUNCTION LIKE WE DID WITH "configureTimelineAlbum()",
     * TO AVOID ADDING BUGGY AND UNMAINTAINABLE SPIDERWEB CODE!
     *
     * @param string $targetFeed       Target feed for this media ("timeline", "story", "direct_story"
     *                                 but NOT "album", they are handled elsewhere).
     * @param array  $internalMetadata Internal library-generated metadata key-value pairs.
     * @param array  $externalMetadata (optional) User-provided metadata key-value pairs.
     *
     * @throws \InvalidArgumentException
     * @throws \InstagramAPI\Exception\InstagramException
     *
     * @return \InstagramAPI\Response\ConfigureResponse
     */
    public function configureSingleVideo(
        $targetFeed,
        array $internalMetadata,
        array $externalMetadata = [])
    {
        // Determine the target endpoint for the video.
        switch ($targetFeed) {
        case 'timeline':
            $endpoint = 'media/configure/';
            break;
        case 'direct_story':
        case 'story':
            $endpoint = 'media/configure_to_story/';
            break;
        default:
            throw new \InvalidArgumentException(sprintf('Bad target feed "%s".', $targetFeed));
        }

        // Available external metadata parameters:
        /** @var string|null Caption to use for the media. */
        $captionText = isset($externalMetadata['caption']) ? $externalMetadata['caption'] : null;
        /** @var string[]|null Array of numerical UserPK IDs of people tagged in
         * your video. ONLY USED IN STORY VIDEOS! TODO: Actually, it's not even
         * implemented for stories. */
        $usertags = (isset($externalMetadata['usertags']) && $targetFeed == 'story') ? $externalMetadata['usertags'] : null;
        /** @var Response\Model\Location|null A Location object describing where
         the media was taken. NOT USED FOR STORY MEDIA! */
        $location = (isset($externalMetadata['location']) && $targetFeed != 'story') ? $externalMetadata['location'] : null;

        // Fix very bad external user-metadata values.
        if (!is_string($captionText)) {
            $captionText = '';
        }

        // Critically important internal library-generated metadata parameters:
        /** @var string The ID of the entry to configure. */
        $uploadId = $internalMetadata['uploadId'];
        /** @var array Video details array. */
        $videoDetails = $internalMetadata['videoDetails'];

        // Build the request...
        $request = $this->ig->request($endpoint)
            ->addParam('video', 1)
            ->addPost('video_result', 'deprecated')
            ->addPost('upload_id', $uploadId)
            ->addPost('poster_frame_index', 0)
            ->addPost('length', round($videoDetails['duration'], 1))
            ->addPost('audio_muted', false)
            ->addPost('filter_type', 0)
            ->addPost('source_type', 4)
            ->addPost('video_result', 'deprecated')
            ->addPost('device',
                [
                    'manufacturer'      => $this->ig->device->getManufacturer(),
                    'model'             => $this->ig->device->getModel(),
                    'android_version'   => $this->ig->device->getAndroidVersion(),
                    'android_release'   => $this->ig->device->getAndroidRelease(),
                ])
            ->addPost('extra',
                [
                    'source_width'  => $videoDetails['width'],
                    'source_height' => $videoDetails['height'],
                ])
            ->addPost('_csrftoken', $this->ig->client->getToken())
            ->addPost('_uuid', $this->ig->uuid)
            ->addPost('_uid', $this->ig->account_id);

        switch ($targetFeed) {
            case 'story':
                $request
                    ->addPost('configure_mode', 1) // 1 - REEL_SHARE
                    ->addPost('story_media_creation_date', time() - mt_rand(10, 20))
                    ->addPost('client_shared_at', time() - mt_rand(3, 10))
                    ->addPost('client_timestamp', time());
                break;
            case 'direct_story':
                $request
                    ->addPost('configure_mode', 2) // 2 - DIRECT_STORY_SHARE
                    ->addPost('recipient_users', $internalMetadata['recipient_users'])
                    ->addPost('thread_ids', $internalMetadata['thread_ids'])
                    ->addPost('story_media_creation_date', time() - mt_rand(10, 20))
                    ->addPost('client_shared_at', time() - mt_rand(3, 10))
                    ->addPost('client_timestamp', time());
                break;
        }

        $request->addPost('caption', $captionText);

        if ($targetFeed == 'story') {
            $request->addPost('story_media_creation_date', time());
            if (!is_null($usertags)) {
                // Reel Mention example:
                // [{\"y\":0.3407772676161919,\"rotation\":0,\"user_id\":\"USER_ID\",\"x\":0.39892578125,\"width\":0.5619921875,\"height\":0.06011525487256372}]
                // NOTE: The backslashes are just double JSON encoding, ignore
                // that and just give us an array with these clean values, don't
                // try to encode it in any way, we do all encoding to match the above.
                // This post field will get wrapped in another json_encode call during transfer.
                $request->addPost('reel_mentions', json_encode($usertags));
            }
        }

        if ($location instanceof Response\Model\Location) {
            $loc = [
                $location->getExternalIdSource().'_id'   => $location->getExternalId(),
                'name'                                   => $location->getName(),
                'lat'                                    => $location->getLat(),
                'lng'                                    => $location->getLng(),
                'address'                                => $location->getAddress(),
                'external_source'                        => $location->getExternalIdSource(),
            ];

            $request
                ->addPost('location', json_encode($loc))
                ->addPost('geotag_enabled', '1')
                ->addPost('posting_latitude', $location->getLat())
                ->addPost('posting_longitude', $location->getLng())
                ->addPost('media_latitude', $location->getLat())
                ->addPost('media_longitude', $location->getLng())
                ->addPost('av_latitude', 0.0)
                ->addPost('av_longitude', 0.0);
        }

        $configure = $request->getResponse(new Response\ConfigureResponse());

        return $configure;
    }

    /**
     * Helper function for reliably configuring videos.
     *
     * Exactly the same as configureSingleVideo() but performs multiple attempts. Very
     * useful since Instagram sometimes can't configure a newly uploaded video
     * file until a few seconds have passed.
     *
     * @param string $targetFeed       Target feed for this media ("timeline", "story", "direct_story"
     *                                 but NOT "album", they are handled elsewhere).
     * @param array  $internalMetadata Internal library-generated metadata key-value pairs.
     * @param array  $externalMetadata (optional) User-provided metadata key-value pairs.
     * @param int    $maxAttempts      Total attempts to configure video before throwing.
     *
     * @throws \InvalidArgumentException
     * @throws \InstagramAPI\Exception\InstagramException
     *
     * @return \InstagramAPI\Response\ConfigureResponse
     *
     * @see Internal::configureSingleVideo() for available metadata fields.
     */
    public function configureSingleVideoWithRetries(
        $targetFeed,
        array $internalMetadata,
        array $externalMetadata = [],
        $maxAttempts = 5)
    {
        // We require at least 1 attempt, otherwise we can't do anything.
        if ($maxAttempts < 1) {
            throw new \InvalidArgumentException('The maxAttempts parameter must be 1 or higher.');
        }

        for ($attempt = 1; $attempt <= $maxAttempts; ++$attempt) {
            try {
                // Attempt to configure video parameters.
                $configure = $this->configureSingleVideo($targetFeed, $internalMetadata, $externalMetadata);
                break; // Success. Exit loop.
            } catch (\InstagramAPI\Exception\InstagramException $e) {
                if ($attempt < $maxAttempts && strpos($e->getMessage(), 'Transcode timeout') !== false) {
                    // Do nothing, since we'll be retrying the failed configure...
                    sleep(1); // Just wait a little before the next retry.
                } else {
                    // Re-throw all unhandled exceptions.
                    throw $e;
                }
            }
        }

        return $configure; // ConfigureResponse
    }

    /**
     * Configures parameters for a whole album of uploaded media files.
     *
     * WARNING TO CONTRIBUTORS: THIS IS ONLY FOR *TIMELINE ALBUMS*. DO NOT MAKE
     * IT DO ANYTHING ELSE, TO AVOID ADDING BUGGY AND UNMAINTAINABLE SPIDERWEB
     * CODE!
     *
     * @param array $media            Extended media array coming from Timeline::uploadAlbum(),
     *                                containing the user's per-file metadata,
     *                                and internally generated per-file metadata.
     * @param array $internalMetadata Internal library-generated metadata key-value pairs.
     * @param array $externalMetadata (optional) User-provided metadata key-value pairs
     *                                for the album itself (its caption, location, etc).
     *
     * @throws \InvalidArgumentException
     * @throws \InstagramAPI\Exception\InstagramException
     *
     * @return \InstagramAPI\Response\ConfigureResponse
     */
    public function configureTimelineAlbum(
        array $media,
        array $internalMetadata,
        array $externalMetadata = [])
    {
        $endpoint = 'media/configure_sidecar/';

        // Available external metadata parameters:
        /** @var string|null Caption to use for the album. */
        $captionText = isset($externalMetadata['caption']) ? $externalMetadata['caption'] : null;
        /** @var Response\Model\Location|null A Location object describing where
         the album was taken. */
        $location = isset($externalMetadata['location']) ? $externalMetadata['location'] : null;

        // Fix very bad external user-metadata values.
        if (!is_string($captionText)) {
            $captionText = '';
        }

        // Critically important internal library-generated metadata parameters:
        // NOTE: NO INTERNAL DATA IS NEEDED HERE YET.

        // Build the album's per-children metadata.
        $date = date('Y:m:d H:i:s');
        $childrenMetadata = [];
        foreach ($media as $item) {
            // Get all of the common, INTERNAL per-file metadata.
            $uploadId = $item['internalMetadata']['uploadId'];

            switch ($item['type']) {
            case 'photo':
                // Get all of the INTERNAL per-PHOTO metadata.
                /** @var int|float */
                $photoWidth = $item['internalMetadata']['photoWidth'];
                /** @var int|float */
                $photoHeight = $item['internalMetadata']['photoHeight'];

                // Build this item's configuration.
                $photoConfig = [
                    'date_time_original'  => $date,
                    'scene_type'          => 1,
                    'disable_comments'    => false,
                    'upload_id'           => $uploadId,
                    'source_type'         => 0,
                    'scene_capture_type'  => 'standard',
                    'date_time_digitized' => $date,
                    'geotag_enabled'      => false,
                    'camera_position'     => 'back',
                    'edits'               => [
                        'filter_strength' => 1,
                        'filter_name'     => 'IGNormalFilter',
                    ],
                ];

                // This usertag per-file EXTERNAL metadata is only supported for PHOTOS!
                if (isset($item['usertags'])) {
                    // NOTE: These usertags are validated in Timeline::uploadAlbum.
                    $photoConfig['usertags'] = json_encode(['in' => $item['usertags']]);
                }

                $childrenMetadata[] = $photoConfig;
                break;
            case 'video':
                // Get all of the INTERNAL per-VIDEO metadata.
                /** @var array Video details array. */
                $videoDetails = $item['internalMetadata']['videoDetails'];

                // Build this item's configuration.
                $videoConfig = [
                    'length'              => round($videoDetails['duration'], 1),
                    'date_time_original'  => $date,
                    'scene_type'          => 1,
                    'poster_frame_index'  => 0,
                    'trim_type'           => 0,
                    'disable_comments'    => false,
                    'upload_id'           => $uploadId,
                    'source_type'         => 'library',
                    'geotag_enabled'      => false,
                    'edits'               => [
                        'length'          => round($videoDetails['duration'], 1),
                        'cinema'          => 'unsupported',
                        'original_length' => round($videoDetails['duration'], 1),
                        'source_type'     => 'library',
                        'start_time'      => 0,
                        'camera_position' => 'unknown',
                        'trim_type'       => 0,
                    ],
                ];

                $childrenMetadata[] = $videoConfig;
                break;
            }
        }

        // Build the request...
        $request = $this->ig->request($endpoint)
            ->addPost('_csrftoken', $this->ig->client->getToken())
            ->addPost('_uid', $this->ig->account_id)
            ->addPost('_uuid', $this->ig->uuid)
            ->addPost('client_sidecar_id', Utils::generateUploadId())
            ->addPost('caption', $captionText)
            ->addPost('children_metadata', $childrenMetadata);

        if ($location instanceof Response\Model\Location) {
            $loc = [
                $location->getExternalIdSource().'_id'   => $location->getExternalId(),
                'name'                                   => $location->getName(),
                'lat'                                    => $location->getLat(),
                'lng'                                    => $location->getLng(),
                'address'                                => $location->getAddress(),
                'external_source'                        => $location->getExternalIdSource(),
            ];

            $request
                ->addPost('location', json_encode($loc))
                ->addPost('geotag_enabled', '1')
                ->addPost('posting_latitude', $location->getLat())
                ->addPost('posting_longitude', $location->getLng())
                ->addPost('media_latitude', $location->getLat())
                ->addPost('media_longitude', $location->getLng())
                ->addPost('exif_latitude', 0.0)
                ->addPost('exif_longitude', 0.0);
        }

        $configure = $request->getResponse(new Response\ConfigureResponse());

        return $configure;
    }

    /**
     * Helper function for reliably configuring albums.
     *
     * Exactly the same as configureTimelineAlbum() but performs multiple
     * attempts. Very useful since Instagram sometimes can't configure a newly
     * uploaded video file until a few seconds have passed.
     *
     * @param array $media            Extended media array coming from Timeline::uploadAlbum(),
     *                                containing the user's per-file metadata,
     *                                and internally generated per-file metadata.
     * @param array $internalMetadata Internal library-generated metadata key-value pairs.
     * @param array $externalMetadata (optional) User-provided metadata key-value pairs
     *                                for the album itself (its caption, location, etc).
     * @param int   $maxAttempts      Total attempts to configure videos before throwing.
     *
     * @throws \InvalidArgumentException
     * @throws \InstagramAPI\Exception\InstagramException
     *
     * @return \InstagramAPI\Response\ConfigureResponse
     *
     * @see Internal::configureTimelineAlbum() for available metadata fields.
     */
    public function configureTimelineAlbumWithRetries(
        array $media,
        array $internalMetadata,
        array $externalMetadata = [],
        $maxAttempts = 5)
    {
        // We require at least 1 attempt, otherwise we can't do anything.
        if ($maxAttempts < 1) {
            throw new \InvalidArgumentException('The maxAttempts parameter must be 1 or higher.');
        }

        for ($attempt = 1; $attempt <= $maxAttempts; ++$attempt) {
            try {
                // Attempt to configure album parameters.
                $configure = $this->configureTimelineAlbum($media, $internalMetadata, $externalMetadata);
                break; // Success. Exit loop.
            } catch (\InstagramAPI\Exception\InstagramException $e) {
                if ($attempt < $maxAttempts && strpos($e->getMessage(), 'Transcode timeout') !== false) {
                    // Do nothing, since we'll be retrying the failed configure...
                    sleep(1); // Just wait a little before the next retry.
                } else {
                    // Re-throw all unhandled exceptions.
                    throw $e;
                }
            }
        }

        return $configure; // ConfigureResponse
    }

    /**
     * Saves active experiments.
     *
     * @param Response\SyncResponse $syncResponse
     *
     * @throws \InstagramAPI\Exception\SettingsException
     */
    protected function _saveExperiments(
        Response\SyncResponse $syncResponse)
    {
        $experiments = [];
        foreach ($syncResponse->experiments as $experiment) {
            if (!isset($experiment->name)) {
                continue;
            }

            $group = $experiment->name;
            if (!isset($experiments[$group])) {
                $experiments[$group] = [];
            }

            if (!isset($experiment->params)) {
                continue;
            }

            foreach ($experiment->params as $param) {
                if (!isset($param->name)) {
                    continue;
                }

                $experiments[$group][$param->name] = $param->value;
            }
        }

        // Save the experiments and the last time we refreshed them.
        $this->ig->experiments = $this->ig->settings->setExperiments($experiments);
        $this->ig->settings->set('last_experiments', time());
    }

    /**
     * Perform an Instagram "feature synchronization" call for device.
     *
     * @param bool $prelogin
     *
     * @throws \InstagramAPI\Exception\InstagramException
     *
     * @return \InstagramAPI\Response\SyncResponse
     */
    public function syncDeviceFeatures(
        $prelogin = false)
    {
        $request = $this->ig->request('qe/sync/')
            ->addPost('id', $this->ig->uuid)
            ->addPost('experiments', Constants::LOGIN_EXPERIMENTS);
        if ($prelogin) {
            $request->setNeedsAuth(false);
        } else {
            $request
                ->addPost('_uuid', $this->ig->uuid)
                ->addPost('_uid', $this->ig->account_id)
                ->addPost('_csrftoken', $this->ig->client->getToken());
        }

        return $request->getResponse(new Response\SyncResponse());
    }

    /**
     * Perform an Instagram "feature synchronization" call for account.
     *
     * @throws \InstagramAPI\Exception\InstagramException
     *
     * @return \InstagramAPI\Response\SyncResponse
     */
    public function syncUserFeatures()
    {
        $result = $this->ig->request('qe/sync/')
            ->addPost('_uuid', $this->ig->uuid)
            ->addPost('_uid', $this->ig->account_id)
            ->addPost('_csrftoken', $this->ig->client->getToken())
            ->addPost('id', $this->ig->account_id)
            ->addPost('experiments', Constants::EXPERIMENTS)
            ->getResponse(new Response\SyncResponse());

        // Save the updated experiments for this user.
        $this->_saveExperiments($result);

        return $result;
    }

    /**
     * Registers advertising identifier.
     *
     * @throws \InstagramAPI\Exception\InstagramException
     *
     * @return \InstagramAPI\Response\GenericResponse
     */
    public function logAttribution()
    {
        return $this->ig->request('attribution/log_attribution/')
            ->setNeedsAuth(false)
            ->addPost('adid', $this->ig->advertising_id)
            ->getResponse(new Response\GenericResponse());
    }

    /**
     * Reads MSISDN header.
     *
     * WARNING. DON'T USE. UNDER RESEARCH.
     *
     * @param string $subnoKey Encoded subscriber number.
     *
     * @throws \InstagramAPI\Exception\InstagramException
     *
     * @return \InstagramAPI\Response\MsisdnHeaderResponse
     *
     * @since 10.24.0 app version.
     */
    public function readMsisdnHeader(
        $subnoKey = null)
    {
        $request = $this->ig->request('accounts/read_msisdn_header/')
            ->setNeedsAuth(false)
            // UUID is used as device_id intentionally.
            ->addPost('device_id', $this->ig->uuid)
            ->addPost('_csrftoken', $this->ig->client->getToken());
        if ($subnoKey !== null) {
            $request->addPost('subno_key', $subnoKey);
        }

        return $request->getResponse(new Response\MsisdnHeaderResponse());
    }

    /**
     * Bootstraps MSISDN header.
     *
     * WARNING. DON'T USE. UNDER RESEARCH.
     *
     * @throws \InstagramAPI\Exception\InstagramException
     *
     * @return \InstagramAPI\Response\MsisdnHeaderResponse
     *
     * @since 10.24.0 app version.
     */
    public function bootstrapMsisdnHeader()
    {
        $request = $this->ig->request('accounts/msisdn_header_bootstrap/')
            ->setNeedsAuth(false)
            // UUID is used as device_id intentionally.
            ->addPost('device_id', $this->ig->uuid)
            ->addPost('_csrftoken', $this->ig->client->getToken());

        return $request->getResponse(new Response\MsisdnHeaderResponse());
    }

    /**
     * Get megaphone log.
     *
     * @throws \InstagramAPI\Exception\InstagramException
     *
     * @return \InstagramAPI\Response\MegaphoneLogResponse
     */
    public function getMegaphoneLog()
    {
        return $this->ig->request('megaphone/log/')
            ->setSignedPost(false)
            ->addPost('type', 'feed_aysf')
            ->addPost('action', 'seen')
            ->addPost('reason', '')
            ->addPost('_uuid', $this->ig->uuid)
            ->addPost('device_id', $this->ig->device_id)
            ->addPost('_csrftoken', $this->ig->client->getToken())
            ->addPost('uuid', md5(time()))
            ->getResponse(new Response\MegaphoneLogResponse());
    }

    /**
     * Get Facebook OTA (Over-The-Air) update information.
     *
     * @throws \InstagramAPI\Exception\InstagramException
     *
     * @return \InstagramAPI\Response\FacebookOTAResponse
     */
    public function getFacebookOTA()
    {
        return $this->ig->request('facebook_ota/')
            ->addParam('fields', Constants::FACEBOOK_OTA_FIELDS)
            ->addParam('custom_user_id', $this->ig->account_id)
            ->addParam('signed_body', Signatures::generateSignature('').'.')
            ->addParam('ig_sig_key_version', Constants::SIG_KEY_VERSION)
            ->addParam('version_code', Constants::VERSION_CODE)
            ->addParam('version_name', Constants::IG_VERSION)
            ->addParam('custom_app_id', Constants::FACEBOOK_ORCA_APPLICATION_ID)
            ->addParam('custom_device_id', $this->ig->uuid)
            ->getResponse(new Response\FacebookOTAResponse());
    }

    /**
     * Get profile "notices".
     *
     * This is just for some internal state information, such as
     * "has_change_password_megaphone". It's not for public use.
     *
     * @throws \InstagramAPI\Exception\InstagramException
     *
     * @return \InstagramAPI\Response\ProfileNoticeResponse
     */
    public function getProfileNotice()
    {
        return $this->ig->request('users/profile_notice/')
            ->addPost('_uuid', $this->ig->uuid)
            ->addPost('_uid', $this->ig->account_id)
            ->addPost('_csrftoken', $this->ig->client->getToken())
            ->getResponse(new Response\ProfileNoticeResponse());
    }

    /**
     * Fetch qp data.
     *
     * @throws \InstagramAPI\Exception\InstagramException
     *
     * @return \InstagramAPI\Response\FetchQPDataResponse
     */
    public function getQPFetch()
    {
        return $this->ig->request('qp/fetch/')
            ->addPost('_uuid', $this->ig->uuid)
            ->addPost('_uid', $this->ig->account_id)
            ->addPost('_csrftoken', $this->ig->client->getToken())
            ->addPost('vc_policy', 'default')
            ->addPost('surface_param', Constants::SURFACE_PARAM)
            ->addPost('version', 1)
            ->addPost('query', "viewer() {\n  eligible_promotions.surface_nux_id(<surface>).external_gating_permitted_qps(<external_gating_permitted_qps>) {\n    edges {\n      priority,\n      time_range {\n        start,\n        end\n      },\n      node {\n        id,\n        promotion_id,\n        max_impressions,\n        triggers,\n        creatives {\n          title {\n            text\n          },\n          content {\n            text\n          },\n          footer {\n            text\n          },\n          social_context {\n            text\n          },\n          primary_action{\n            title {\n              text\n            },\n            url,\n            limit,\n            dismiss_promotion\n          },\n          secondary_action{\n            title {\n              text\n            },\n            url,\n            limit,\n            dismiss_promotion\n          },\n          dismiss_action{\n            title {\n              text\n            },\n            url,\n            limit,\n            dismiss_promotion\n          },\n          image {\n            uri\n          }\n        }\n      }\n    }\n  }\n}\n")
            ->getResponse(new Response\FetchQPDataResponse());
    }

    /**
     * Send analytics and events to Instagram's Analytics Server.
     *
     * @param array $data Analytics and event data array.
     *
     * @throws \InstagramAPI\Exception\InstagramException
     *
     * @return \InstagramAPI\Response\ClientEventLogsResponse
     */
    public function sendClientEventLogs(
        array $data)
    {
        $message = base64_encode(gzcompress(json_encode($data)));
        $message = urlencode($message); // Yep, we must URL-encode this data!

        return $this->ig->request(Constants::GRAPH_URL.'logging_client_events')
            ->addPost('message', $message)
            ->addPost('compressed', '1')
            ->addPost('access_token', Constants::ANALYTICS_ACCESS_TOKEN)
            ->addPost('format', 'json')
            ->getResponse(new Response\ClientEventLogsResponse());
    }

    /**
     * Performs a chunked upload of a video file, with support for retries.
     *
     * Note that chunk uploads often get dropped when their server is overloaded
     * at peak hours, which is why the "max attempts" parameter exists. We will
     * try that many times to upload all chunks. The retries will only re-upload
     * the exact chunks that have been dropped from their server, and it won't
     * waste time with chunks that are already successfully uploaded.
     *
     * @param string $targetFeed    Target feed for this media ("timeline", "story", "album" or "direct_v2").
     * @param string $videoFilename The video filename.
     * @param array  $uploadParams  An array created by Request\Internal::requestVideoUploadURL()!
     * @param int    $maxAttempts   Total attempts to upload all chunks before throwing.
     *
     * @throws \InvalidArgumentException
     * @throws \InstagramAPI\Exception\InstagramException
     * @throws \InstagramAPI\Exception\UploadFailedException If the upload fails.
     *
     * @return \InstagramAPI\Response\UploadVideoResponse
     */
    public function uploadVideoChunks(
        $targetFeed,
        $videoFilename,
        array $uploadParams,
        $maxAttempts = 10)
    {
        // We require at least 1 attempt, otherwise we can't do anything.
        if ($maxAttempts < 1) {
            throw new \InvalidArgumentException('The maxAttempts parameter must be 1 or higher.');
        }

        // Verify that the file exists locally.
        if (!is_file($videoFilename)) {
            throw new \InvalidArgumentException(sprintf(
                'The video file "%s" does not exist on disk.',
                $videoFilename
            ));
        }

        // To support video uploads to albums, we MUST fake-inject the
        // "sessionid" cookie from "i.instagram" into our "upload.instagram"
        // request, otherwise the server will reply with a "StagedUpload not
        // found" error when the final chunk has been uploaded.
        $sessionIDCookie = null;
        if ($targetFeed == 'album') {
            $foundCookie = $this->ig->client->getCookie('sessionid', 'i.instagram.com');
            if ($foundCookie !== null) {
                $sessionIDCookie = $foundCookie->getValue();
            }
            if ($sessionIDCookie === null) { // Verify value.
                throw new \InstagramAPI\Exception\UploadFailedException(
                    'Unable to find the necessary SessionID cookie for uploading video album chunks.'
                );
            }
        }

        // Determine correct file extension for the video format.
        $videoExt = pathinfo($videoFilename, PATHINFO_EXTENSION);
        if (strlen($videoExt) == 0) {
            $videoExt = 'mp4'; // Fallback.
        }

        // Video uploads should be chunked to save RAM; determine chunk size!
        $videoSize = filesize($videoFilename);
        if ($videoSize < 1) {
            throw new \InstagramAPI\Exception\UploadFailedException(sprintf(
                'Upload of "%s" failed. The file is empty.',
                $videoFilename
            ));
        }
        $numChunks = ceil($videoSize / 524288); // We want <= 512KB per chunk.
        $maxChunkSize = ceil($videoSize / $numChunks); // Calc actual chunksize.

        // Calculate the per-chunk parameters and byte ranges.
        $videoChunks = [];
        $remainingBytes = $videoSize; // Tracks remaining bytes in video file.
        $rangeStart = 0;
        for ($chunkIdx = 1; $chunkIdx <= $numChunks; ++$chunkIdx) {
            // Use "max chunk size" OR remaining bytes, whichever is smaller.
            $chunkSize = $chunkIdx >= $numChunks
                ? $remainingBytes // Final chunk uses remaining bytes.
                : min($remainingBytes, $maxChunkSize); // Smallest num.
            if ($chunkSize <= 0) {
                break; // Prevent empty chunks.
            }

            // Track how many bytes now remain in the file after this chunk.
            $remainingBytes -= $chunkSize;

            // Calculate where the current byte range will end.
            // NOTE: Range is 0-indexed, and Start is the first byte of the
            // new chunk we're uploading, hence we MUST subtract 1 from End.
            // And our FINAL chunk's End must be 1 less than the filesize!
            $rangeEnd = $rangeStart + ($chunkSize - 1);

            // Add the current chunk's parameters to the list.
            $videoChunks[] = [
                'fileOffset' => $rangeStart, // fseek offsets are 0-indexed too!
                'chunkSize'  => $chunkSize, // Size (in bytes) of this chunk.
                'rangeStart' => $rangeStart, // Start offset for the HTTP chunk.
                'rangeEnd'   => $rangeEnd, // End offset for the HTTP chunk.
            ];

            // Update the range's Start for the next iteration.
            // NOTE: It's the End-byte of the previous range, plus one.
            $rangeStart = $rangeEnd + 1;
        }

        // Read and upload each individual chunk, doing retries when necessary.
        $handle = fopen($videoFilename, 'r');
        $httpResponse = null;
        try {
            $uploadedRanges = [];
            for ($attempt = 1; $attempt <= $maxAttempts; ++$attempt) {
                // Upload all missing chunks to the server for this attempt.
                foreach ($videoChunks as $chunk) {
                    // Skip this chunk if the server already has it.
                    foreach ($uploadedRanges as $serverRange) {
                        if ($serverRange['start'] <= $chunk['rangeStart']
                            && $serverRange['end'] >= $chunk['rangeEnd']) {
                            continue 2; // Iterate to the next chunk.
                        }
                    }

                    // Seek to the exact file byte-offset of this chunk.
                    $result = fseek($handle, $chunk['fileOffset'], SEEK_SET);
                    if ($result !== 0) {
                        throw new \InstagramAPI\Exception\UploadFailedException(sprintf(
                            'Upload of "%s" failed. Unable to seek to the %d byte offset.',
                            $videoFilename, $chunk['fileOffset']
                        ));
                    }

                    // Attempt to read the exact bytes we need for this chunk.
                    $chunkData = fread($handle, $chunk['chunkSize']);
                    if (strlen($chunkData) != $chunk['chunkSize']) {
                        throw new \InstagramAPI\Exception\UploadFailedException(sprintf(
                            'Upload of "%s" failed. Unable to read %d bytes from file.',
                            $videoFilename, $chunk['chunkSize']
                        ));
                    }

                    // Prepare request.
                    $request = new Request($this->ig, $uploadParams['uploadUrl']);
                    $request
                        ->setAddDefaultHeaders(false)
                        ->addHeader('Content-Type', 'application/octet-stream')
                        ->addHeader('Session-ID', $uploadParams['uploadId'])
                        ->addHeader('Content-Disposition', 'attachment; filename="video.mov"')
                        ->addHeader('Content-Range', 'bytes '.$chunk['rangeStart'].'-'.$chunk['rangeEnd'].'/'.$videoSize)
                        ->addHeader('job', $uploadParams['job'])
                        ->setBody(stream_for($chunkData));

                    // When uploading videos to albums, we must fake-inject the
                    // "sessionid" cookie (the official app fake-injects it too).
                    if ($targetFeed == 'album' && $sessionIDCookie !== null) {
                        // We'll add it with the default options ("single use")
                        // so the fake cookie is only added to THIS request.
                        $this->ig->client->getMiddleware()->addFakeCookie('sessionid', $sessionIDCookie);
                    }

                    // Perform the upload of the current chunk.
                    $httpResponse = $request->getHttpResponse();

                    // Process the server response...
                    switch ($httpResponse->getStatusCode()) {
                        case 200:
                            // All chunks are uploaded. Break out of our main upload-loop.
                            break 3;
                        case 201:
                            // The server has given us a regular reply. We expect it
                            // to be a range-reply, such as "0-3912399/23929393".
                            // Their server often drops chunks during peak hours,
                            // and in that case the first range may not start at
                            // zero, or there may be gaps or multiple ranges, such
                            // as "0-4076155/8152310,6114234-8152309/8152310". We'll
                            // handle that by re-uploading whatever they've dropped.
                            $range = $httpResponse->getHeaderLine('Range');
                            if (!strlen($range)) {
                                // Fail if the response contains no byte ranges!
                                throw new \InstagramAPI\Exception\UploadFailedException(sprintf(
                                    "Upload of \"%s\" failed. Instagram's server returned empty range.",
                                    $videoFilename, $range
                                ));
                            }
                            preg_match_all('/(?<start>\d+)-(?<end>\d+)\/(?<total>\d+)/', $range, $matches, PREG_SET_ORDER);
                            if (count($matches) == 0) {
                                // Fail if the response contains invalid byte ranges!
                                throw new \InstagramAPI\Exception\UploadFailedException(sprintf(
                                    "Upload of \"%s\" failed. Instagram's server returned an unexpected range (\"%s\").",
                                    $videoFilename, $range
                                ));
                            }

                            // Keep track of which range(s) the server has received,
                            // so that we will re-upload their missing ranges.
                            $uploadedRanges = [];
                            foreach ($matches as $match) {
                                $uploadedRanges[] = [
                                    'start' => $match['start'],
                                    'end'   => $match['end'],
                                ];
                            }
                            break;
                        default:
                            // TODO add more status codes (such as 400, 403, 422, 503, 511 ...)
                    }
                }
            }
        } finally {
            // Guaranteed to release handle even if something bad happens above!
            fclose($handle);
        }

        // NOTE: $httpResponse below refers to the final chunk's result!
        if ($httpResponse === null) {
            throw new \InstagramAPI\Exception\UploadFailedException(sprintf(
                'Upload of \"%s\" failed. No response from server.',
                $videoFilename
            ));
        }

        // Protection against Instagram's upload server being bugged out!
        // NOTE: When their server is bugging out, the final chunk result will
        // still be yet another range specifier such as "328600-657199/657200",
        // instead of a "{...}" JSON object. Because their server will have
        // dropped some chunks when they bug out (due to overload or w/e).
        if (substr($httpResponse->getBody(), 0, 1) !== '{') {
            throw new \InstagramAPI\Exception\UploadFailedException(sprintf(
                "Upload of \"%s\" failed. Instagram's server returned an unexpected reply and is probably overloaded.",
                $videoFilename
            ));
        }

        // Manually decode the final API response and check for successful chunked upload.
        /** @var Response\UploadVideoResponse $upload */
        $upload = $this->ig->client->getMappedResponseObject(
            new Response\UploadVideoResponse(),
            Client::api_body_decode((string) $httpResponse->getBody()), // Important: Special JSON decoder.
            $httpResponse
        );

        return $upload;
    }
}
